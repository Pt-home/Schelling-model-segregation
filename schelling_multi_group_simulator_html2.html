<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Schelling Multi-Group Simulator (розширений)</title>
  <style>
    :root {
      --bg:#f7f7fb; --panel:#ffffff; --ink:#222; --muted:#6b7280; --accent:#2563eb;
      --grid:#0f172a22; --btn:#e5e7eb; --btn-ink:#111827; --btn-hover:#d1d5db;
    }
    * { box-sizing: border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji'; }
    body { margin:0; background:var(--bg); color:var(--ink); display:flex; justify-content:center; }
    .wrap { width:min(1160px, 100%); padding:16px; }
    h1 { font-size:22px; margin:6px 0 12px; }

    .layout { display:grid; grid-template-columns: 1fr 360px; gap:16px; align-items:start; }
    #boardFrame { background:var(--panel); padding:8px; border-radius:10px; box-shadow:0 4px 16px rgba(0,0,0,.06); }
    #canvas { width:100%; height:auto; display:block; border:1px solid #e5e7eb; image-rendering: pixelated; }

    .panel { background:var(--panel); border-radius:10px; padding:12px; box-shadow:0 4px 16px rgba(0,0,0,.06); }
    .row { display:flex; align-items:center; justify-content:space-between; gap:10px; margin:8px 0; }
    .row label { font-size:14px; color:var(--muted); }
    .val { min-width:64px; text-align:right; font-variant-numeric: tabular-nums; }

    input[type=range] { width: 100%; accent-color: var(--accent); }
    input[type=number] { width: 90px; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px; }
    select { width: 100%; padding:6px 8px; border:1px solid #e5e7eb; border-radius:8px; background:#fff; }
    input[type=color] { width: 40px; height: 28px; padding:0; border:1px solid #e5e7eb; border-radius:6px; background:#fff; }

    .btns { display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; margin:12px 0 6px; }
    button { border:0; padding:8px 10px; border-radius:9px; background:var(--btn); color:var(--btn-ink); cursor:pointer; font-weight:600; }
    button:hover { background:var(--btn-hover); }
    button.primary { background:var(--accent); color:white; }
    button.primary:hover { filter:brightness(.95); }
    .meta { font-size:13px; color:var(--muted); margin-top:6px; display:flex; gap:18px; }

    .legend { display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
    .chip { display:inline-flex; align-items:center; gap:6px; padding:6px 8px; border:1px solid #e5e7eb; border-radius:999px; font-size:12px; }
    .sw { width:14px; height:14px; border-radius:3px; border:1px solid #0003; }

    .hr { height:1px; background:#e5e7eb; margin:10px -12px; }
    .note { font-size:12px; color:var(--muted); line-height:1.35; }
    .toggle { display:flex; align-items:center; gap:8px; }
    .toggle input { transform: scale(1.1); }

    .export { display:grid; grid-template-columns: repeat(2, 1fr); gap:8px; margin-top:6px; }

    #paletteBox { display:none; border:1px dashed #e5e7eb; border-radius:8px; padding:8px; margin-top:6px; }
    #paletteGrid { display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; }

    @media (max-width: 980px) {
      .layout { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Модель Шеллінга з кількома групами — розширена</h1>
  <div class="layout">
    <div id="boardFrame" class="panel">
      <canvas id="canvas" width="900" height="900"></canvas>
      <div class="meta">
        <div>Раунд: <b id="round">0</b></div>
        <div>Задоволені: <b id="satisfied">0%</b></div>
      </div>
    </div>

    <div class="panel">
      <div class="btns">
        <button id="reset">Reset</button>
        <button id="start" class="primary">Start</button>
        <button id="stop">Stop</button>
        <button id="step">Step</button>
        <button id="exportCSV">CSV</button>
        <button id="exportJSON">JSON</button>
        <button id="exportPNG">PNG</button>
        <button id="exportNPY">NPY</button>
      </div>

      <div class="row">
        <label>Поріг подібності</label>
        <div class="val" id="lblTol">64%</div>
      </div>
      <input id="tol" type="range" min="0" max="100" step="1" value="64" />
      <div class="note" id="tolHint">Рекомендовано: ~50%</div>

      <div class="row">
        <label>Груп (кольорів)</label>
        <div class="val" id="lblGroups">3</div>
      </div>
      <input id="groups" type="range" min="2" max="12" step="1" value="3" />

      <div class="row">
        <label>Порожніх клітин</label>
        <div class="val" id="lblEmpty">18%</div>
      </div>
      <input id="empty" type="range" min="0" max="60" step="1" value="18" />

      <div class="row">
        <label>Розмір ґратки</label>
        <div class="val" id="lblSize">66×66</div>
      </div>
      <input id="size" type="range" min="20" max="160" step="2" value="66" />

      <div class="row">
        <label>Затримка кроку</label>
        <div class="val" id="lblDelay">100 ms</div>
      </div>
      <input id="delay" type="range" min="0" max="800" step="20" value="100" />

      <div class="hr"></div>

      <div class="row">
        <label for="nbhdSel">Окіл</label>
        <select id="nbhdSel">
          <option value="moore">Мура (8)</option>
          <option value="neumann">фон Неймана (4)</option>
        </select>
      </div>
      <div class="row">
        <label>Радіус околу</label>
        <div class="val" id="lblR">1</div>
      </div>
      <input id="radius" type="range" min="1" max="5" step="1" value="1" />

      <div class="row">
        <label for="topoSel">Топологія</label>
        <select id="topoSel">
          <option value="bounded">Площина (з краями)</option>
          <option value="torus">Тор (обгортання)</option>
        </select>
      </div>

      <div class="row toggle">
        <input id="weighted" type="checkbox" />
        <label for="weighted">Зважувати сусідів за відстанню (w = 1 / (1 + d))</label>
      </div>

      <div class="hr"></div>

      <div class="row toggle">
        <input id="palToggle" type="checkbox" />
        <label for="palToggle">Кастомна палітра</label>
      </div>
      <div id="paletteBox">
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:4px;">
          <button id="palRandom">Випадково</button>
          <span class="note">Зміни нижче застосовуються одразу.</span>
        </div>
        <div id="paletteGrid"></div>
      </div>

      <div class="hr"></div>
      <div class="legend" id="legend"></div>

      <div class="note" style="margin-top:8px">
        <ul>
          <li>Значення осередків: <b>-1</b> — порожньо, <b>0..K-1</b> — індекси груп.</li>
          <li>Критерій: частка «своїх» серед зайнятих сусідів (зважено/незважено) ≥ порога.</li>
          <li>Окіл: Мура або фон Неймана, радіус r≥1. Топологія: площина або тор.</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id)=>document.getElementById(id);
  const canvas = $('canvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // ---------- STATE ----------
  const state = {
    N: 66,
    K: 3,
    emptyPct: 0.18,
    tol: 0.64,
    delay: 100,
    running: false,
    round: 0,
    satisfiedPct: 0,
    grid: [],
    empties: [],
    palette: [],
    recordHistory: false,
    history: [],
    timer: null,

    // нове:
    nbhd: 'moore', // 'moore' | 'neumann'
    radius: 1,
    torus: false,
    weighted: false,

    // препрораховані сусіди
    NB: [],      // масив сусідів індексів
    NBw: []      // відповідні ваги (тільки якщо weighted)
  };

  // ---------- UTILS ----------
  function hslToHex(h, s, l){
    h/=360; s/=100; l/=100;
    const hue2rgb=(p,q,t)=>{ if(t<0) t+=1; if(t>1) t-=1; if(t<1/6) return p+(q-p)*6*t; if(t<1/2) return q; if(t<2/3) return p+(q-p)*(2/3 - t)*6; return p; };
    const q = l < .5 ? l*(1+s) : l + s - l*s; const p = 2*l - q;
    const r = Math.round(hue2rgb(p,q,h+1/3)*255);
    const g = Math.round(hue2rgb(p,q,h)*255);
    const b = Math.round(hue2rgb(p,q,h-1/3)*255);
    return '#' + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join('');
  }

  function buildPalette(K){
    const arr = [];
    for(let i=0;i<K;i++){
      const hue = (360*i)/K;
      arr.push(hslToHex(hue, 70, 55));
    }
    return arr;
  }

  function setLabels(){
    $('lblTol').textContent = Math.round(state.tol*100) + '%';
    $('lblGroups').textContent = state.K;
    $('lblEmpty').textContent = Math.round(state.emptyPct*100) + '%';
    $('lblSize').textContent = `${state.N}×${state.N}`;
    $('lblDelay').textContent = `${state.delay} ms`;
    $('lblR').textContent = state.radius;
    $('tolHint').textContent = 'Рекомендовано: ~' + Math.round(recommendedTol()*100) + '%';
  }

  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
  const copyGrid = (g)=>g.map(row=>row.slice());

  function idx(r,c){ return r*state.N + c; }
  function rc(i){ const N=state.N; return [ (i/N)|0, i%N ]; }
  function wrap(x,n){ return (x % n + n) % n; }

  // ---------- NEIGHBORHOODS ----------
  function buildOffsets(){
    const r = state.radius, nbhd = state.nbhd;
    const offs = [];
    if(nbhd === 'moore'){
      for(let dr=-r; dr<=r; dr++){
        for(let dc=-r; dc<=r; dc++){
          if(dr===0 && dc===0) continue;
          if(Math.max(Math.abs(dr), Math.abs(dc)) <= r) offs.push([dr,dc]);
        }
      }
    } else { // neumann
      for(let dr=-r; dr<=r; dr++){
        for(let dc=-r; dc<=r; dc++){
          if(dr===0 && dc===0) continue;
          if(Math.abs(dr)+Math.abs(dc) <= r) offs.push([dr,dc]);
        }
      }
    }
    return offs;
  }

  function precomputeNeighbors(){
    const N = state.N, TOR = state.torus;
    const offs = buildOffsets();
    const NB = new Array(N*N);
    const NBw = new Array(N*N);
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const ns = [], ws = [];
        for(const [dr,dc] of offs){
          let rr=r+dr, cc=c+dc;
          if(TOR){ rr = wrap(rr,N); cc = wrap(cc,N); ns.push(idx(rr,cc)); }
          else { if(rr<0||cc<0||rr>=N||cc>=N) continue; ns.push(idx(rr,cc)); }
          // вага за евклідовою відстанню (1/(1+d)):
          const d = Math.hypot(dr,dc);
          ws.push(1/(1+d));
        }
        NB[idx(r,c)] = ns;
        NBw[idx(r,c)] = ws;
      }
    }
    state.NB = NB;
    state.NBw = NBw;
    setLabels(); // оновити рекомендацію порога
  }

  function neighborsCount(){
    // Скільки сусідів у внутрішній клітинки (без країв)
    const r = state.radius, nbhd = state.nbhd;
    return (nbhd === 'moore') ? (2*r+1)*(2*r+1) - 1 : (2*r*(r+1));
  }

  function recommendedTol(){
    // ceil(половина сусідів)/сусіди — напівціле «50%+» без врахування порожніх
    const n = Math.max(1, neighborsCount());
    return Math.ceil(n/2)/n;
  }

  // ---------- INIT / RESET ----------
  function updateLegend(){
    const el = $('legend'); el.innerHTML = '';
    for(let i=0;i<state.K;i++){
      const chip = document.createElement('div');
      chip.className = 'chip';
      const sw = document.createElement('div'); sw.className='sw'; sw.style.background = state.palette[i];
      const span = document.createElement('span'); span.textContent = `Група ${i}`;
      chip.appendChild(sw); chip.appendChild(span); el.appendChild(chip);
    }
  }

  function newRandomGrid(){
    const N = state.N; const total = N*N;
    const emptiesCount = Math.round(total * state.emptyPct);
    const cells = new Array(total).fill(-1);
    const occupants = total - emptiesCount;
    const perGroup = Math.floor(occupants/state.K);
    let idxp = 0;
    for(let k=0;k<state.K;k++){
      const cnt = (k===state.K-1) ? (occupants - perGroup*(state.K-1)) : perGroup;
      for(let c=0;c<cnt;c++){ cells[idxp++] = k; }
    }
    shuffle(cells);
    state.grid = Array.from({length:N}, (_,r)=>cells.slice(r*N,(r+1)*N));
    recomputeEmpties();
    state.history = []; if(state.recordHistory) state.history.push(copyGrid(state.grid));
    state.round = 0; state.satisfiedPct = 0; updateMeta(); draw();
  }

  function recomputeEmpties(){
    const N = state.N; state.empties = [];
    for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(state.grid[r][c]===-1) state.empties.push([r,c]);
  }

  // ---------- DRAW ----------
  function draw(){
    const N = state.N; const cell = Math.floor(Math.min(W,H)/N);
    ctx.clearRect(0,0,W,H);
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const v = state.grid[r][c];
        ctx.fillStyle = (v===-1) ? '#ffffff' : state.palette[v];
        ctx.fillRect(c*cell, r*cell, cell, cell);
      }
    }
    ctx.strokeStyle = 'rgba(15,23,42,.2)'; ctx.lineWidth = 1;
    for(let i=0;i<=N;i++){
      ctx.beginPath(); ctx.moveTo(0, i*cell+0.5); ctx.lineTo(N*cell, i*cell+0.5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(i*cell+0.5, 0); ctx.lineTo(i*cell+0.5, N*cell); ctx.stroke();
    }
  }

  // ---------- SATISFACTION ----------
  function satisfactionAt_rc(r,c,type){
    const i = idx(r,c);
    const arr = state.grid;
    const ns = state.NB[i];
    const ws = state.NBw[i];
    if(!state.weighted){
      let same=0, neigh=0;
      for(const j of ns){
        const [rr,cc] = rc(j);
        const v = arr[rr][cc];
        if(v!==-1){ neigh++; if(v===type) same++; }
      }
      if(neigh===0) return 1;
      return same / neigh;
    } else {
      let wSum=0, wSame=0;
      for(let k=0;k<ns.length;k++){
        const j = ns[k], w = ws[k];
        const [rr,cc] = rc(j);
        const v = arr[rr][cc];
        if(v!==-1){ wSum+=w; if(v===type) wSame+=w; }
      }
      if(wSum<=1e-12) return 1;
      return wSame / wSum;
    }
  }

  function computeUnsatisfied(){
    const N = state.N; const unsat = [];
    let satisfied = 0, totalAgents = 0;
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const v = state.grid[r][c];
        if(v===-1) continue; totalAgents++;
        const sat = satisfactionAt_rc(r,c,v);
        if(sat + 1e-9 < state.tol) unsat.push([r,c]); else satisfied++;
      }
    }
    state.satisfiedPct = totalAgents? Math.round(100*satisfied/totalAgents) : 100;
    return unsat;
  }

  function findSpotFor(type){
    if(state.empties.length===0) return -1;
    const idxs = [...state.empties.keys()]; shuffle(idxs);
    for(const i of idxs){
      const [r,c] = state.empties[i];
      if(satisfactionAt_rc(r,c,type) + 1e-9 >= state.tol) return i;
    }
    return -1;
  }

  // ---------- SIM ----------
  function stepOnce(){
    const unsat = computeUnsatisfied();
    if(unsat.length===0){ stop(); return; }
    shuffle(unsat);

    for(const [r,c] of unsat){
      const type = state.grid[r][c];
      let i = findSpotFor(type);
      if(i===-1){ i = Math.floor(Math.random()*state.empties.length); }
      const [nr,nc] = state.empties[i];
      state.grid[nr][nc] = type;
      state.grid[r][c] = -1;
      state.empties[i] = [r,c];
    }
    state.round++;
    if(state.recordHistory) state.history.push(copyGrid(state.grid));
    updateMeta(); draw();
  }

  function start(){ if(state.running) return; state.running = true; clearInterval(state.timer); state.timer = setInterval(stepOnce, Math.max(0,state.delay)); }
  function stop(){ state.running = false; clearInterval(state.timer); }

  function updateMeta(){ $('round').textContent = state.round; $('satisfied').textContent = state.satisfiedPct + '%'; }

  // ---------- EXPORT ----------
  function exportCSV(){
    const N=state.N, K=state.K;
    const head = `# K=${K}, N=${N}, tol=${state.tol}, empty=${state.emptyPct}, round=${state.round}, nbhd=${state.nbhd}, radius=${state.radius}, torus=${state.torus}, weighted=${state.weighted}`;
    const lines = [head];
    for(let r=0;r<N;r++){ lines.push(state.grid[r].join(',')); }
    downloadBlob(new Blob([lines.join('\n')],{type:'text/csv;charset=utf-8'}), `schelling_${N}x${N}_K${K}_r${state.round}.csv`);
  }

  function exportJSON(){
    const payload = {
      N: state.N, K: state.K, tol: state.tol, empty: state.emptyPct,
      rounds: state.round, recordHistory: state.recordHistory,
      nbhd: state.nbhd, radius: state.radius, torus: state.torus, weighted: state.weighted,
      palette: state.palette,
      grids: state.recordHistory ? state.history : [state.grid]
    };
    downloadBlob(new Blob([JSON.stringify(payload)],{type:'application/json'}),
      `schelling_${state.N}x${state.N}_K${state.K}_history.json`);
  }

  function exportPNG(){
    // Рендер у канву з легендою під полем
    const N=state.N, cell = Math.floor(Math.min(W,H)/N);
    const legendH = 28 + Math.ceil(state.K/8)*22; // примірна висота
    const out = document.createElement('canvas');
    out.width = N*cell; out.height = N*cell + legendH;
    const c2 = out.getContext('2d');
    // поле
    c2.drawImage(canvas, 0, 0);
    // білий низ під легенду
    c2.fillStyle = '#ffffff'; c2.fillRect(0, N*cell, out.width, legendH);
    // легенда
    c2.fillStyle = '#111'; c2.font = '12px system-ui, Arial';
    let x=8, y=N*cell+18, cnt=0;
    for(let i=0;i<state.K;i++){
      // кольорова мітка
      c2.fillStyle = state.palette[i]; c2.fillRect(x, y-10, 14, 14);
      c2.strokeStyle = '#0003'; c2.strokeRect(x, y-10, 14, 14);
      c2.fillStyle = '#111'; c2.fillText('Група '+i, x+20, y+2);
      x += 90; cnt++;
      if(cnt%8===0){ x=8; y+=22; }
    }
    downloadBlob(outToBlob(out), `schelling_${N}x${N}_K${state.K}_r${state.round}.png`);
  }

  function outToBlob(cv){
    // Canvas to PNG Blob
    const dataURL = cv.toDataURL('image/png');
    const bstr = atob(dataURL.split(',')[1]);
    const u8 = new Uint8Array(bstr.length);
    for(let i=0;i<bstr.length;i++) u8[i]=bstr.charCodeAt(i);
    return new Blob([u8], {type:'image/png'});
  }

  // .NPY v1.0 writer (int16, C-order)
  function exportNPY(){
    const N = state.N;
    const data = new Int16Array(N*N);
    for(let r=0;r<N;r++) for(let c=0;c<N;c++) data[r*N+c] = state.grid[r][c];
    const headerObj = {
      descr: '<i2',           // little-endian int16
      fortran_order: false,
      shape: [N,N]
    };
    const header = JSON.stringify(headerObj).replace(/:/g, ': ').replace(/,/g, ', ')
                    .replace(/"/g,"'"); // numpy expects single quotes
    let pre = `{'descr': '${headerObj.descr}', 'fortran_order': False, 'shape': (${N}, ${N})}`;
    // pad to 16-byte alignment + newline
    const magic = '\x93NUMPY';
    const ver = new Uint8Array([0x01,0x00]); // v1.0
    const hlen = 10 + 2; // magic(6)+ver(2)+hlen(2) already accounted later
    let headerStr = pre + ' '.repeat(64) + '\n';
    // recompute to fit alignment
    function makeHeader(){
      let h = `{'descr': '<i2', 'fortran_order': False, 'shape': (${N}, ${N})}`;
      const baseLen = 6+2+2 + h.length + 1; // magic+ver+hlen+header+'\n'
      const pad = (16 - (baseLen % 16)) % 16;
      return h + ' '.repeat(pad) + '\n';
    }
    headerStr = makeHeader();
    const headerBytes = new TextEncoder().encode(headerStr);
    const hlenLE = new Uint8Array(2); const dv = new DataView(hlenLE.buffer); dv.setUint16(0, headerBytes.length, true);

    const magicBytes = new TextEncoder().encode(magic);
    const out = new Blob([magicBytes, ver, hlenLE, headerBytes, new Uint8Array(data.buffer)], {type:'application/octet-stream'});
    downloadBlob(out, `schelling_${N}x${N}_grid_int16.npy`);
  }

  function downloadBlob(blob, name){
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name; a.click(); URL.revokeObjectURL(a.href);
  }

  // ---------- PALETTE ----------
  function rebuildPaletteUI(){
    const box = $('paletteGrid'); box.innerHTML = '';
    for(let i=0;i<state.K;i++){
      const wrap = document.createElement('div');
      const row = document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px';
      const lab = document.createElement('span'); lab.textContent = `#${i}`;
      const inp = document.createElement('input'); inp.type='color'; inp.value = rgbToHex(state.palette[i]);
      inp.oninput = (e)=>{ state.palette[i] = e.target.value; updateLegend(); draw(); };
      row.appendChild(lab); row.appendChild(inp); wrap.appendChild(row); box.appendChild(wrap);
    }
  }

  function rgbToHex(col){
    // supports hex already
    if(col.startsWith('#')) return col;
    // otherwise parse hsl(...) — не викликатиметься у нас
    return '#000000';
  }

  function randomizePalette(){
    for(let i=0;i<state.K;i++){
      const hue = Math.floor(Math.random()*360);
      state.palette[i] = hslToHex(hue, 70, 55);
    }
    updateLegend(); rebuildPaletteUI(); draw();
  }

  // ---------- UI BINDINGS ----------
  $('reset').onclick = ()=>{ stop(); precomputeNeighbors(); newRandomGrid(); };
  $('start').onclick = start;
  $('stop').onclick = stop;
  $('step').onclick = ()=>{ stop(); stepOnce(); };

  $('exportCSV').onclick = exportCSV;
  $('exportJSON').onclick = exportJSON;
  $('exportPNG').onclick = exportPNG;
  $('exportNPY').onclick = exportNPY;

  $('tol').oninput   = (e)=>{ state.tol = +e.target.value/100; setLabels(); };
  $('groups').oninput= (e)=>{ state.K = +e.target.value; state.palette = buildPalette(state.K); updateLegend(); rebuildPaletteUI(); setLabels(); newRandomGrid(); };
  $('empty').oninput = (e)=>{ state.emptyPct = +e.target.value/100; setLabels(); newRandomGrid(); };
  $('size').oninput  = (e)=>{ state.N = +e.target.value; setLabels(); precomputeNeighbors(); newRandomGrid(); };
  $('delay').oninput = (e)=>{ state.delay = +e.target.value; setLabels(); if(state.running){ stop(); start(); } };

  $('nbhdSel').onchange = (e)=>{ state.nbhd = e.target.value; precomputeNeighbors(); setLabels(); draw(); };
  $('radius').oninput   = (e)=>{ state.radius = +e.target.value; setLabels(); precomputeNeighbors(); draw(); };
  $('topoSel').onchange = (e)=>{ state.torus = (e.target.value==='torus'); precomputeNeighbors(); draw(); };
  $('weighted').onchange= (e)=>{ state.weighted = e.target.checked; setLabels(); draw(); };

  $('palToggle').onchange = (e)=>{ $('paletteBox').style.display = e.target.checked ? 'block' : 'none'; };
  $('palRandom').onclick = randomizePalette;

  // ---------- BOOT ----------
  state.palette = buildPalette(state.K);
  updateLegend(); setLabels(); rebuildPaletteUI(); precomputeNeighbors(); newRandomGrid();

})();
</script>
</body>
</html>
